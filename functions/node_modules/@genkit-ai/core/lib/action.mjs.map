{"version":3,"sources":["../src/action.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { JSONSchema7 } from 'json-schema';\nimport type * as z from 'zod';\nimport { lazy } from './async.js';\nimport { getContext, runWithContext, type ActionContext } from './context.js';\nimport type { ActionType, Registry } from './registry.js';\nimport { parseSchema } from './schema.js';\nimport {\n  SPAN_TYPE_ATTR,\n  newTrace,\n  setCustomMetadataAttributes,\n} from './tracing.js';\n\nexport { StatusCodes, StatusSchema, type Status } from './statusTypes.js';\nexport type { JSONSchema7 };\n\nconst makeNoopAbortSignal = () => new AbortController().signal;\n\n/**\n * Action metadata.\n */\nexport interface ActionMetadata<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> {\n  actionType?: ActionType;\n  name: string;\n  description?: string;\n  inputSchema?: I;\n  inputJsonSchema?: JSONSchema7;\n  outputSchema?: O;\n  outputJsonSchema?: JSONSchema7;\n  streamSchema?: S;\n  metadata?: Record<string, any>;\n  detached?: boolean;\n}\n\n/**\n * Results of an action run. Includes telemetry.\n */\nexport interface ActionResult<O> {\n  result: O;\n  telemetry: {\n    traceId: string;\n    spanId: string;\n  };\n}\n\n/**\n * Options (side channel) data to pass to the model.\n */\nexport interface ActionRunOptions<S> {\n  /**\n   * Streaming callback (optional).\n   */\n  onChunk?: StreamingCallback<S>;\n\n  /**\n   * Additional runtime context data (ex. auth context data).\n   */\n  context?: ActionContext;\n\n  /**\n   * Additional span attributes to apply to OT spans.\n   */\n  telemetryLabels?: Record<string, string>;\n\n  /**\n   * Abort signal for the action request.\n   */\n  abortSignal?: AbortSignal;\n}\n\n/**\n * Options (side channel) data to pass to the model.\n */\nexport interface ActionFnArg<S> {\n  /**\n   * Whether the caller of the action requested streaming.\n   */\n  streamingRequested: boolean;\n\n  /**\n   * Streaming callback (optional).\n   */\n  sendChunk: StreamingCallback<S>;\n\n  /**\n   * Additional runtime context data (ex. auth context data).\n   */\n  context?: ActionContext;\n\n  /**\n   * Trace context containing trace and span IDs.\n   */\n  trace: {\n    traceId: string;\n    spanId: string;\n  };\n\n  /**\n   * Abort signal for the action request.\n   */\n  abortSignal: AbortSignal;\n}\n\n/**\n * Streaming response from an action.\n */\nexport interface StreamingResponse<\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> {\n  /** Iterator over the streaming chunks. */\n  stream: AsyncGenerator<z.infer<S>>;\n  /** Final output of the action. */\n  output: Promise<z.infer<O>>;\n}\n\n/**\n * Self-describing, validating, observable, locally and remotely callable function.\n */\nexport type Action<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n  RunOptions extends ActionRunOptions<S> = ActionRunOptions<S>,\n> = ((input?: z.infer<I>, options?: RunOptions) => Promise<z.infer<O>>) & {\n  __action: ActionMetadata<I, O, S>;\n  __registry: Registry;\n  run(\n    input?: z.infer<I>,\n    options?: ActionRunOptions<z.infer<S>>\n  ): Promise<ActionResult<z.infer<O>>>;\n\n  stream(\n    input?: z.infer<I>,\n    opts?: ActionRunOptions<z.infer<S>>\n  ): StreamingResponse<O, S>;\n};\n\n/**\n * Self-describing, validating, observable, locally and remotely callable function.\n */\nexport type DetachedAction<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n  RunOptions extends ActionRunOptions<S> = ActionRunOptions<S>,\n> = {\n  __action: ActionMetadata<I, O, S>;\n  attach(registry: Registry): Action<I, O, S, RunOptions>;\n};\n\n/**\n * Action factory params.\n */\nexport type ActionParams<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> = {\n  name:\n    | string\n    | {\n        pluginId: string;\n        actionId: string;\n      };\n  description?: string;\n  inputSchema?: I;\n  inputJsonSchema?: JSONSchema7;\n  outputSchema?: O;\n  outputJsonSchema?: JSONSchema7;\n  metadata?: Record<string, any>;\n  use?: Middleware<z.infer<I>, z.infer<O>, z.infer<S>>[];\n  streamSchema?: S;\n  actionType: ActionType;\n};\n\nexport type ActionAsyncParams<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> = ActionParams<I, O, S> & {\n  fn: (\n    input: z.infer<I>,\n    options: ActionFnArg<z.infer<S>>\n  ) => Promise<z.infer<O>>;\n};\n\nexport type SimpleMiddleware<I = any, O = any> = (\n  req: I,\n  next: (req?: I) => Promise<O>\n) => Promise<O>;\n\nexport type MiddlewareWithOptions<I = any, O = any, S = any> = (\n  req: I,\n  options: ActionRunOptions<S> | undefined,\n  next: (req?: I, options?: ActionRunOptions<S>) => Promise<O>\n) => Promise<O>;\n\n/**\n * Middleware function for actions.\n */\nexport type Middleware<I = any, O = any, S = any> =\n  | SimpleMiddleware<I, O>\n  | MiddlewareWithOptions<I, O, S>;\n\n/**\n * Creates an action with provided middleware.\n */\nexport function actionWithMiddleware<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  action: Action<I, O, S>,\n  middleware: Middleware<z.infer<I>, z.infer<O>, z.infer<S>>[]\n): Action<I, O, S> {\n  const wrapped = (async (\n    req: z.infer<I>,\n    options?: ActionRunOptions<z.infer<S>>\n  ) => {\n    return (await wrapped.run(req, options)).result;\n  }) as Action<I, O, S>;\n  wrapped.__action = action.__action;\n  wrapped.__registry = action.__registry;\n  wrapped.run = async (\n    req: z.infer<I>,\n    options?: ActionRunOptions<z.infer<S>>\n  ): Promise<ActionResult<z.infer<O>>> => {\n    let telemetry;\n    const dispatch = async (\n      index: number,\n      req: z.infer<I>,\n      opts?: ActionRunOptions<z.infer<S>>\n    ) => {\n      if (index === middleware.length) {\n        // end of the chain, call the original model action\n        const result = await action.run(req, opts);\n        telemetry = result.telemetry;\n        return result.result;\n      }\n\n      const currentMiddleware = middleware[index];\n      if (currentMiddleware.length === 3) {\n        return (currentMiddleware as MiddlewareWithOptions<I, O, z.infer<S>>)(\n          req,\n          opts,\n          async (modifiedReq, modifiedOptions) =>\n            dispatch(index + 1, modifiedReq || req, modifiedOptions || opts)\n        );\n      } else if (currentMiddleware.length === 2) {\n        return (currentMiddleware as SimpleMiddleware<I, O>)(\n          req,\n          async (modifiedReq) => dispatch(index + 1, modifiedReq || req, opts)\n        );\n      } else {\n        throw new Error('unspported middleware function shape');\n      }\n    };\n    wrapped.stream = action.stream;\n\n    return { result: await dispatch(0, req, options), telemetry };\n  };\n  return wrapped;\n}\n\n/**\n * Creates an action with the provided config.\n */\nexport function action<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  registry: Registry,\n  config: ActionParams<I, O, S>,\n  fn: (\n    input: z.infer<I>,\n    options: ActionFnArg<z.infer<S>>\n  ) => Promise<z.infer<O>>\n): Action<I, O, z.infer<S>> {\n  return detachedAction(config, fn).attach(registry);\n}\n\n/**\n * Creates an action with the provided config.\n */\nexport function detachedAction<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  config: ActionParams<I, O, S>,\n  fn: (\n    input: z.infer<I>,\n    options: ActionFnArg<z.infer<S>> & { registry: Registry }\n  ) => Promise<z.infer<O>>\n): DetachedAction<I, O, z.infer<S>> {\n  const actionName =\n    typeof config.name === 'string'\n      ? config.name\n      : `${config.name.pluginId}/${config.name.actionId}`;\n  const actionMetadata = {\n    name: actionName,\n    description: config.description,\n    inputSchema: config.inputSchema,\n    inputJsonSchema: config.inputJsonSchema,\n    outputSchema: config.outputSchema,\n    outputJsonSchema: config.outputJsonSchema,\n    streamSchema: config.streamSchema,\n    metadata: config.metadata,\n    actionType: config.actionType,\n    detached: true,\n  } as ActionMetadata<I, O, S>;\n\n  return {\n    __action: actionMetadata,\n    attach(registry: Registry): Action<I, O, z.infer<S>> {\n      const actionFn = async (\n        input?: I,\n        options?: ActionRunOptions<z.infer<S>>\n      ) => {\n        return (await actionFn.run(input, options)).result;\n      };\n      actionFn.__registry = registry;\n      actionFn.__action = { ...actionMetadata };\n      delete actionFn.__action['detached'];\n\n      actionFn.run = async (\n        input: z.infer<I>,\n        options?: ActionRunOptions<z.infer<S>>\n      ): Promise<ActionResult<z.infer<O>>> => {\n        input = parseSchema(input, {\n          schema: config.inputSchema,\n          jsonSchema: config.inputJsonSchema,\n        });\n        let traceId;\n        let spanId;\n        let output = await newTrace(\n          registry,\n          {\n            name: actionName,\n            labels: {\n              [SPAN_TYPE_ATTR]: 'action',\n              'genkit:metadata:subtype': config.actionType,\n              ...options?.telemetryLabels,\n            },\n          },\n          async (metadata, span) => {\n            setCustomMetadataAttributes(registry, {\n              subtype: config.actionType,\n            });\n            if (options?.context) {\n              setCustomMetadataAttributes(registry, {\n                context: JSON.stringify(options.context),\n              });\n            }\n\n            traceId = span.spanContext().traceId;\n            spanId = span.spanContext().spanId;\n            metadata.name = actionName;\n            metadata.input = input;\n\n            try {\n              const actionFn = () =>\n                fn(input, {\n                  ...options,\n                  // Context can either be explicitly set, or inherited from the parent action.\n                  context: {\n                    ...registry.context,\n                    ...(options?.context ?? getContext(registry)),\n                  },\n                  streamingRequested:\n                    !!options?.onChunk &&\n                    options.onChunk !== sentinelNoopStreamingCallback,\n                  sendChunk: options?.onChunk ?? sentinelNoopStreamingCallback,\n                  trace: {\n                    traceId,\n                    spanId,\n                  },\n                  registry,\n                  abortSignal: options?.abortSignal ?? makeNoopAbortSignal(),\n                });\n              // if context is explicitly passed in, we run action with the provided context,\n              // otherwise we let upstream context carry through.\n              const output = await runWithContext(\n                registry,\n                options?.context,\n                actionFn\n              );\n\n              metadata.output = JSON.stringify(output);\n              return output;\n            } catch (err) {\n              if (typeof err === 'object') {\n                (err as any).traceId = traceId;\n              }\n              throw err;\n            }\n          }\n        );\n        output = parseSchema(output, {\n          schema: config.outputSchema,\n          jsonSchema: config.outputJsonSchema,\n        });\n        return {\n          result: output,\n          telemetry: {\n            traceId,\n            spanId,\n          },\n        };\n      };\n\n      actionFn.stream = (\n        input?: z.infer<I>,\n        opts?: ActionRunOptions<z.infer<S>>\n      ): StreamingResponse<O, S> => {\n        let chunkStreamController: ReadableStreamController<z.infer<S>>;\n        const chunkStream = new ReadableStream<z.infer<S>>({\n          start(controller) {\n            chunkStreamController = controller;\n          },\n          pull() {},\n          cancel() {},\n        });\n\n        const invocationPromise = actionFn\n          .run(config.inputSchema ? config.inputSchema.parse(input) : input, {\n            onChunk: ((chunk: z.infer<S>) => {\n              chunkStreamController.enqueue(chunk);\n            }) as S extends z.ZodVoid\n              ? undefined\n              : StreamingCallback<z.infer<S>>,\n            context: {\n              ...registry.context,\n              ...(opts?.context ?? getContext(registry)),\n            },\n            abortSignal: opts?.abortSignal,\n            telemetryLabels: opts?.telemetryLabels,\n          })\n          .then((s) => s.result)\n          .finally(() => {\n            chunkStreamController.close();\n          });\n\n        return {\n          output: invocationPromise,\n          stream: (async function* () {\n            const reader = chunkStream.getReader();\n            while (true) {\n              const chunk = await reader.read();\n              if (chunk.value) {\n                yield chunk.value;\n              }\n              if (chunk.done) {\n                break;\n              }\n            }\n            return await invocationPromise;\n          })(),\n        };\n      };\n\n      if (config.use) {\n        return actionWithMiddleware(actionFn, config.use);\n      }\n      return actionFn;\n    },\n  };\n}\n\nexport function isAction(a: unknown): a is Action {\n  return (\n    typeof a === 'function' && '__action' in a && !(a as any).__action.detached\n  );\n}\n\nexport function isDetachedAction(a: unknown): a is DetachedAction {\n  return (\n    !!(a as DetachedAction).__action &&\n    !!(a as DetachedAction).__action.detached &&\n    typeof (a as DetachedAction).attach === 'function'\n  );\n}\n\n/**\n * Defines an action with the given config and registers it in the registry.\n */\nexport function defineAction<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  registry: Registry,\n  config: ActionParams<I, O, S>,\n  fn: (\n    input: z.infer<I>,\n    options: ActionFnArg<z.infer<S>>\n  ) => Promise<z.infer<O>>\n): Action<I, O, S> {\n  if (isInRuntimeContext(registry)) {\n    throw new Error(\n      'Cannot define new actions at runtime.\\n' +\n        'See: https://github.com/firebase/genkit/blob/main/docs/errors/no_new_actions_at_runtime.md'\n    );\n  }\n  const act = action(\n    registry,\n    config,\n    async (i: I, options): Promise<z.infer<O>> => {\n      await registry.initializeAllPlugins();\n      return await runInActionRuntimeContext(registry, () => fn(i, options));\n    }\n  );\n  act.__action.actionType = config.actionType;\n  registry.registerAction(config.actionType, act);\n  return act;\n}\n\n/**\n * Defines an action with the given config promise and registers it in the registry.\n */\nexport function defineActionAsync<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  registry: Registry,\n  actionType: ActionType,\n  name:\n    | string\n    | {\n        pluginId: string;\n        actionId: string;\n      },\n  config: PromiseLike<ActionAsyncParams<I, O, S>>,\n  onInit?: (action: Action<I, O, S>) => void\n): PromiseLike<Action<I, O, S>> {\n  const actionName =\n    typeof name === 'string' ? name : `${name.pluginId}/${name.actionId}`;\n  const actionPromise = lazy(() =>\n    config.then((resolvedConfig) => {\n      const act = action(\n        registry,\n        resolvedConfig,\n        async (i: I, options): Promise<z.infer<O>> => {\n          await registry.initializeAllPlugins();\n          return await runInActionRuntimeContext(registry, () =>\n            resolvedConfig.fn(i, options)\n          );\n        }\n      );\n      act.__action.actionType = actionType;\n      onInit?.(act);\n      return act;\n    })\n  );\n  registry.registerActionAsync(actionType, actionName, actionPromise);\n  return actionPromise;\n}\n\n// Streaming callback function.\nexport type StreamingCallback<T> = (chunk: T) => void;\n\nconst streamingAlsKey = 'core.action.streamingCallback';\nexport const sentinelNoopStreamingCallback = () => null;\n\n/**\n * Executes provided function with streaming callback in async local storage which can be retrieved\n * using {@link getStreamingCallback}.\n */\nexport function runWithStreamingCallback<S, O>(\n  registry: Registry,\n  streamingCallback: StreamingCallback<S> | undefined,\n  fn: () => O\n): O {\n  return registry.asyncStore.run(\n    streamingAlsKey,\n    streamingCallback || sentinelNoopStreamingCallback,\n    fn\n  );\n}\n\n/**\n * Retrieves the {@link StreamingCallback} previously set by {@link runWithStreamingCallback}\n *\n * @hidden\n */\nexport function getStreamingCallback<S>(\n  registry: Registry\n): StreamingCallback<S> | undefined {\n  const cb =\n    registry.asyncStore.getStore<StreamingCallback<S>>(streamingAlsKey);\n  if (cb === sentinelNoopStreamingCallback) {\n    return undefined;\n  }\n  return cb;\n}\n\nconst runtimeContextAslKey = 'core.action.runtimeContext';\n\n/**\n * Checks whether the caller is currently in the runtime context of an action.\n */\nexport function isInRuntimeContext(registry: Registry) {\n  return registry.asyncStore.getStore(runtimeContextAslKey) === 'runtime';\n}\n\n/**\n * Execute the provided function in the action runtime context.\n */\nexport function runInActionRuntimeContext<R>(registry: Registry, fn: () => R) {\n  return registry.asyncStore.run(runtimeContextAslKey, 'runtime', fn);\n}\n\n/**\n * Execute the provided function outside the action runtime context.\n */\nexport function runOutsideActionRuntimeContext<R>(\n  registry: Registry,\n  fn: () => R\n) {\n  return registry.asyncStore.run(runtimeContextAslKey, 'outside', fn);\n}\n"],"mappings":"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","names":["action","req","actionFn","output"]}